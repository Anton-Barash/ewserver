var fs = require('fs');
var mime = require('mime');
var convert = require('xml-js');
var crypto = require('crypto');

function isArray (obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
};

function isObject (obj) {
	return Object.prototype.toString.call(obj) === '[object Object]'
}

function getType (obj) {
	return Object.prototype.toString.call(obj).replace(/(.*? |])/g, '').toLowerCase()
}

function firstUpperCase (key, exclude = []) {
	if (exclude.indexOf(key) > -1) return obj
	return key.replace(/^./, (_) => _.toUpperCase());
}

/**
 * 将obj的key首字母转成大写
 * @param {*} obj 
 * @param {*} options {exclude: []} 不做处理的key
 */
function formatObjKey (obj, options = {}) {
	if (obj === null || typeof obj !== 'object') return obj

	let tmp = null

	if (isArray(obj)) {
		tmp = []
		for (let i = 0, len = obj.length; i < len; i++) {
			tmp.push(formatObjKey(obj[i]))
		}
	} else {
		tmp = {}
		Object.keys(obj).forEach(key => {
			const k = firstUpperCase(key, options.exclude)
			tmp[k] = formatObjKey(obj[key], options.exclude)
		})
	}

	return tmp;
}

/**
 * 获取字符串的字符长度
 * @param {*} str 
 */
function getStrBytesCount (str) {
	let counts = 0
	for (let i = 0, len = str.length; i < len; i++) {
		const char = str.charAt(i)
		// /[^\u0000-\u00FF]/ (匹配非单字节字符 )
		if (/[^\u0000-\u00FF]/.test(char)) {
			counts += 2
		} else {
			counts += 1
		}
	}
	return counts
}

/**
 * 校验bucketName的可用性
 */
function verifyBucket(name) {
	var flag = true;
	var len = name.length;
	var re = /^[a-z0-9]+([\.-]*([a-z0-9])*)*[a-z0-9]+$/;
	if (len >= 3 && len <= 63) {
		flag = re.test(name)
	} else {
		flag = false;
	}
	return flag;
}
/**
 * 验证ACL权限
 */
function verifyAcl(acl) {
	var flag = null;
	var acls = ['private', 'public-read', 'public-read-write', 'authenticated-read', 'bucket-owner-read', 'bucket-owner-full-control'];
	var reg = new RegExp('^' + acl + '$', 'i');
	acls.forEach(function(name) {
		if (reg.test(name)) {
			flag = name.toLowerCase();
			return flag;
		}
	})
	return flag;
}
/**
 * 验证存储类型
 */
 function verifyBucketType(type) {
	var flag = null;
	var types = ['NORMAL', 'ARCHIVE']
	var reg = new RegExp('^' + type + '$', 'i');
	types.forEach(function(name) {
		if (reg.test(name)) {
			flag = name.toLowerCase();
			return flag;
		}
	})
	return flag;
}

/**
 * 验证对象的存储类型
 * @param {*} type 
 */
function verifyStorageClass (type) {
	var flag = null;
	var types = ['STANDARD', 'STANDARD_IA', 'ARCHIVE']
	var reg = new RegExp('^' + type + '$', 'i');
	types.forEach(function(name) {
		if (reg.test(name)) {
			flag = name.toLowerCase();
			return flag;
		}
	})
	return flag;
}

/**
 * key 进行encodeURIComponent编码，'/'不能被编码
 * 
 */
function encodeKey(key) {
	var newKey = encodeURIComponent(key);
	newKey = newKey.replace(/%2F/g, '/');
	if (newKey.startsWith('/')) newKey = newKey.replace('/', '%2F')
	// '//'needs convert to '/%2F'
	if (newKey.includes('//')) newKey = newKey.replace(/\/\//g, '/%2F')
	if (newKey.includes('\'')) newKey = newKey.replace(/\'/g, '%27')
	return newKey
}

/**
 * 处理外链的编码
 * @param {*} result 
 * @returns 
 * @description
 * - 有些字符是不会被转码的 所以需要手动转码， 例如："%2C!%3D%3F%2B()'~%C2%B0"
 * 
 */
function encodePresignedUrlKey (urlKey) {
	let result = encodeKey(urlKey)
	const specialKeyMap = {
		'(': '%28',
		')': '%29',
		'!': '%21',
		// '~': '%7E', 该字符不可转
		'\'': '%27'
	}

	Object.keys(specialKeyMap).forEach(key => {
		if (result.indexOf(key) > -1) {
			let tempKey = key
			// () 是正则的组 需要特别处理
			if (key == '(' || key == ')') key = `\\${key}`
			const regExp = new RegExp(key, 'gim')
			result = result.replace(regExp, specialKeyMap[tempKey]);
		}
	})
	return result
}

/**
 * 遍历文件
 */
function walkFile(p, opt, fileList) {
	var fileList = fileList || [];
	var _config = {
		isDeep: false,
		ignore: /\s/ig
	};
	var dirList = fs.readdirSync(p);
	for (var it in opt) {
		_config[it] = opt[it];
	}
	dirList.forEach(function(item) {
		if (!_config.ignore.test(item)) {
			if (_config.isDeep) {
				if (fs.statSync(p + '/' + item).isDirectory()) {
					fileList.push(p + '/' + item);
					walkFile(p + '/' + item, opt, fileList);
				} else {
					fileList.push(p + '/' + item);
				}
			} else {
				fileList.push(p + '/' + item);
			}
		}

	});

	return fileList;
}

/**
 * 遍历文件夹
 */
function walkDir(p, opt) {
	var fileList = walkFile(p, opt);
	var dirList = [];
	fileList.forEach(function(item) {
		if (fs.statSync(item).isDirectory()) {
			dirList.push(item);
		}
	});

	return dirList;
}

/*
xml2json v 1.1
copyright 2005-2007 Thomas Frank

This program is free software under the terms of the 
GNU General Public License version 2 as published by the Free 
Software Foundation. It is distributed without any warranty.
*/

var xml2json = {
	parser: function(xmlcode, ignoretags, debug) {
		if (!ignoretags) {
			ignoretags = ""
		};
		xmlcode = xmlcode.replace(/\s*\/>/g, '/>');
		xmlcode = xmlcode.replace(/<\?[^>]*>/g, "").replace(/<\![^>]*>/g, "");
		if (!ignoretags.sort) {
			ignoretags = ignoretags.split(",")
		};
		var x = this.no_fast_endings(xmlcode);
		x = this.attris_to_tags(x, false);
		x = this.remove_prefix(x)
		x = escape(x);
		x = x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i = 0; i < ignoretags.length; i++) {
			x = x.replace(new RegExp("<" + ignoretags[i] + ">", "g"), "*$**" + ignoretags[i] + "**$*");
			x = x.replace(new RegExp("</" + ignoretags[i] + ">", "g"), "*$***" + ignoretags[i] + "**$*")
		};
		x = '<JSONTAGWRAPPER>' + x + '</JSONTAGWRAPPER>';
		this.xmlobject = {};
		var y = this.xml_to_object(x).jsontagwrapper;
		if (debug) {
			y = this.show_json_structure(y, debug)
		};

		const tmp = JSON.stringify(y)
		const res = this.convert_val(tmp)
		return JSON.parse(res)
	},
	xml_to_object: function(xmlcode) {
		var x = xmlcode.replace(/<\//g, "§");
		x = x.split("<");
		var y = [];
		var level = 0;
		var opentags = [];
		for (var i = 1; i < x.length; i++) {
			var tagname = x[i].split(">")[0];
			opentags.push(tagname);
			level++;
			y.push(level + "<" + x[i].split("§")[0]);
			while (x[i].indexOf("§" + opentags[opentags.length - 1] + ">") >= 0) {
				level--;
				opentags.pop()
			}
		};
		var oldniva = - 1;
		var objname = "this.xmlobject";
		for (var i = 0; i < y.length; i++) {
			var preeval = "";
			var niva = y[i].split("<")[0];
			var tagnamn = y[i].split("<")[1].split(">")[0];
			tagnamn = tagnamn == 'JSONTAGWRAPPER' ? tagnamn.toLowerCase() : tagnamn;
			var rest = y[i].split(">")[1];
			if (niva <= oldniva) {
				var tabort = oldniva - niva + 1;
				for (var j = 0; j < tabort; j++) {
					objname = objname.substring(0, objname.lastIndexOf("."))
				}
			};
			objname += "." + tagnamn;
			var pobject = objname.substring(0, objname.lastIndexOf("."));
			if (eval("typeof " + pobject) != "object") {
				preeval += pobject + "={value:" + pobject + "};\n"
			};
			var objlast = objname.substring(objname.lastIndexOf(".") + 1);
			var already = false;
			for (var k in eval(pobject)) {
				if (k == objlast) {
					already = true
				}
			};
			var onlywhites = true;
			for (var s = 0; s < rest.length; s += 3) {
				if (rest.charAt(s) != "%") {
					onlywhites = false
				}
			};
			if (rest != "" && ! onlywhites) {
				if (rest / 1 != rest) {
					rest = "'" + rest.replace(/\'/g, "\\'") + "'";
					rest = rest.replace(/\*\$\*\*\*/g, "</");
					rest = rest.replace(/\*\$\*\*/g, "<");
					rest = rest.replace(/\*\*\$\*/g, ">")
				}
			}
			else {
				rest = "{}"
			};
			if (rest.charAt(0) == "'") {
				// rest = 'unescape(' + rest + ')'
				rest = 'decodeURIComponent(' + rest + ')'
			};
			if (already && ! eval(objname + ".sort")) {
				preeval += objname + "=[" + objname + "];\n"
			};
			var before = "=";
			var after = "";
			if (already) {
				before = ".push(";
				after = ")"
			};
			if (rest.startsWith('0')) rest = '"' + rest + '"'
			var toeval = preeval + objname + before + rest + after;
			eval(toeval);
			if (eval(objname + ".sort")) {
				objname += "[" + eval(objname + ".length-1") + "]"
			};
			oldniva = niva
		};
		return this.xmlobject
	},
	show_json_structure: function(obj, debug, l) {
		var x = '';
		if (obj.sort) {
			x += "[\n"
		} else {
			x += "{\n"
		};
		for (var i in obj) {
			if (!obj.sort) {
				x += i + ":"
			};
			if (typeof obj[i] == "object") {
				x += this.show_json_structure(obj[i], false, 1)
			}
			else {
				if (typeof obj[i] == "function") {
					var v = obj[i] + "";
					//v=v.replace(/\t/g,"");
					x += v
				}
				else if (typeof obj[i] != "string") {
					x += obj[i] + ",\n"
				}
				else {
					x += "'" + obj[i].replace(/\'/g, "\\'").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r") + "',\n"
				}
			}
		};
		if (obj.sort) {
			x += "],\n"
		} else {
			x += "},\n"
		};
		if (!l) {
			x = x.substring(0, x.lastIndexOf(","));
			x = x.replace(new RegExp(",\n}", "g"), "\n}");
			x = x.replace(new RegExp(",\n]", "g"), "\n]");
			var y = x.split("\n");
			x = "";
			var lvl = 0;
			for (var i = 0; i < y.length; i++) {
				if (y[i].indexOf("}") >= 0 || y[i].indexOf("]") >= 0) {
					lvl--
				};
				tabs = "";
				for (var j = 0; j < lvl; j++) {
					tabs += "\t"
				};
				x += tabs + y[i] + "\n";
				if (y[i].indexOf("{") >= 0 || y[i].indexOf("[") >= 0) {
					lvl++
				}
			};
			if (debug == "html") {
				x = x.replace(/</g, "&lt;").replace(/>/g, "&gt;");
				x = x.replace(/\n/g, "<BR>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug == "compact") {
				x = x.replace(/\n/g, "").replace(/\t/g, "")
			}
		};
		return x
	},
	no_fast_endings: function(x) {
		x = x.split("/>");
		for (var i = 1; i < x.length; i++) {
			var t = x[i - 1].substring(x[i - 1].lastIndexOf("<") + 1).split(" ")[0];
			x[i] = "></" + t + ">" + x[i]
		};
		x = x.join("");
		return x
	},
	attris_to_tags: function(x, flag = true) {
		var d = ' ="\''.split("");
		x = x.split(">");
		for (var i = 0; i < x.length; i++) {
			var temp = x[i].split("<");
			for (var r = 0; r < 4; r++) {
				temp[0] = temp[0].replace(new RegExp(d[r], "g"), "_jsonconvtemp" + r + "_")
			};
			if (temp[1]) {
				if (flag) {
					temp[1] = temp[1].replace(/'/g, '"');
					temp[1] = temp[1].split('"');
					for (var j = 1; j < temp[1].length; j += 2) {
						for (var r = 0; r < 4; r++) {
							temp[1][j] = temp[1][j].replace(new RegExp(d[r], "g"), "_jsonconvtemp" + r + "_")
						}
					};
					temp[1] = temp[1].join('"')
				} else {
					temp[1] = temp[1].split(d[0])[0];
				}
			};
			x[i] = temp.join("<")
		};
		x = x.join(">");
		x = x.replace(/ ([^=]*)=([^ |>]*)/g, "><$1>$2</$1");
		x = x.replace(/>"/g, ">").replace(/"</g, "<");
		for (var r = 0; r < 4; r++) {
			x = x.replace(new RegExp("_jsonconvtemp" + r + "_", "g"), d[r])
		};
		return x
	},
	remove_prefix: function (x) {
		// first：find common prefix  eg: '<ns2:'  reg: <[\w]+:
		var reg = /<[\w]+:/g
		var res = x.match(reg)
		if (res) {
			const key = res[0].replace('<', '');
			return x.replace(new RegExp(key,'gm'), '')
		}
		return x
	},
	convert_val: function (val) {
		let s = '';
		if (val.length == 0) return '';
		s = val.replace(/&lt;/g, '<');
		s = s.replace(/&gt;/g, '>');
		s = s.replace(/&#39;/g, '\'');
		s = s.replace(/&quot;/g, '\"');
		s = s.replace(/&amp;/g, '&');
		
		return s;
	}
};

if (!Array.prototype.push) {
	Array.prototype.push = function(x) {
		this[this.length] = x;
		return true
	}
};

if (!Array.prototype.pop) {
	Array.prototype.pop = function() {
		var response = this[this.length - 1];
		this.length--;
		return response
	}
};

/**
 * 获取分块数据
 * @param {*} filePath  文件路径
 * @param {*} chunkSize 分块大小
 * @param {*} start 	开始位置
 * @param {*} cb 		回调方法
 */
function getChunk (filePath, chunkSize, start, cb) {
	fs.open(filePath, 'r', function(err, fd) {
		fs.fstat(fd, function(err, stat) {
			var bufferSize = stat.size;

			var index = start / chunkSize;

			if (start + chunkSize > bufferSize) {
				chunkSize = bufferSize - start;
			}
			var buffer = Buffer.allocUnsafe(chunkSize)
			fs.read(fd, buffer, 0, chunkSize, start, function(err, byteRead, buf) {
				cb(buf)
			})
		})
	})
}

/**
 * 获取文件 按照等比例分块后的块数
 * 
 * @param {*} filePath 文件路径
 * @param {*} chunkSize 分块大小
 */
function getTotalChunk (filePath, chunkSize) {
	var stat = fs.statSync(filePath)
	var fileSize = stat.size;
	// 总块数
	var count = parseInt(fileSize / chunkSize) + ((fileSize % chunkSize == 0 ? 0: 1));
	
	return count
}

/**
 * 分块完成时 需要通过提供的xml文件进行分块组装，在xml文件中，块号必须使用升序排列，必须提供每个块的ETag值
 * @param {*} etags etags数组
 * @returns 
 */
function generateCompleteXML (etags) {
	var str = '';
	var index = etags.length
	if (index > 0) {
		str = '<CompleteMultipartUpload>';
		for (var i = 1; i <= index; i++) {
			str += '<Part><PartNumber>' + i + '</PartNumber><ETag>' + etags[i-1] + '</ETag></Part>'
		}
		str += '</CompleteMultipartUpload>';
	}
	return str;
}

/**
 * 通过key获取对应的content-type值
 * @param {*} key
 * @returns 
 */
function getContentTypeByKey (key) {
	return mime.lookup(key) || ''
}


/**
 *  上面的xml解析功能欠缺 所以使用了xml-js库解析已上传块数据
 * @param {*} xml xml json数据
 * @returns 
 */
function getETagsFromXml (xml) {
	const json = convert.xml2json(xml)
	const data = JSON.parse(json)
    const tags = []
    const nodes = data.elements[0].elements;
    nodes.forEach(node => {
        if (node.name === 'ns2:Part') {
        	node.elements.forEach(item => {
        		let tmp = {}
        		if (item.name === 'ETag') {
        			tmp.etag = item.elements[0].text
        		}
        		if (item.name === 'PartNumber') {
        			tmp.PartNumber = item.elements[0].text
        		}
        		if (JSON.stringify(tmp) !== '{}') tags.push(tag)
        	})
        }
    })
    return tags
}

/**
 * 获取过期时间
 * @param {*} expries 过期时长 单位s
 */
function getExpiresTime (expries) {
	const currentTimestamp = new Date().getTime()
	const date = new Date(currentTimestamp + expries * 1000)
	return date.getTime().toString().substr(0,10)
}

/**
 * 将obj转成k=v&k=v格式
 * @param {*} obj 
 */
function paramsEncode (obj) {
	var str = ''
	for(var key in obj) {
		if (str !== '') {
			str += '&'
		}
		str += key + '=' + encodeURIComponent(obj[key])
	}
	return str;
}

/**
 * 获取文件的md5
 * @param {*} file 
 * @param {*} cb 
 * @returns 
 * @description 
 * 	先使用md5获取文件指纹，再通过base64将结果转成指定格式，上传object时如遇大文件比较耗时，
 * 	故上传操作不建议使用
 */
function getFileMd5 (file, cb){
	var md5 = crypto.createHash('md5')
	const stream = fs.createReadStream(file)
	stream.on('data', chunk => {
		md5.update(chunk);
	});
	stream.on('error', function (err) {
        cb(err);
    });
	stream.on('end', () => {
		const res = md5.digest('base64');
		cb(res)
	});
};

/**
 * 计算指定字符串的Md5值
 * @param {*} str 
 * @returns 
 */
function getStringMd5 (str) {
	if (!str) {
		throw new error('计算字符串md5值失败, str不能为空')
	}
	return crypto.createHash('md5').update(str).digest('base64')
}


function toArray(obj) {
	if (!obj) return [];
	if (isArray(obj)) return obj;
	return [obj];
}

/**
 * 转化成CORS所要求的xml参数
 * @param {*} rules 
 */
function convertToCORSXML (rules) {
	let xml = '<CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">'
	const parseMethod = (val) => {
		xml += `<AllowedMethod>${val}</AllowedMethod>`
	}
	const parseOrigin = (val) => {
		xml += `<AllowedOrigin>${val}</AllowedOrigin>`
	}
	const parseHeader = (val) => {
		xml += `<AllowedHeader>${val}</AllowedHeader>`
	}

	const parseExposeHeader = (val) => {
		xml += `<ExposeHeader>${val}</ExposeHeader>`;
	}

	for (let i = 0, len = rules.length; i < len; i ++) {
		const rule = rules[i]
		xml += '<CORSRule>'
		toArray(rule.allowedMethod).forEach(parseMethod)
		toArray(rule.allowedOrigin).forEach(parseOrigin)
		toArray(rule.allowedHeader).forEach(parseHeader)
		toArray(rule.exposeHeader).forEach(parseExposeHeader)
		if (rule.maxAgeSeconds) {
			xml += `<MaxAgeSeconds>${rule.maxAgeSeconds}</MaxAgeSeconds>`;
		}

		xml += `</CORSRule>`
	}

	xml += '</CORSConfiguration>'
	return xml;
}

/**
 * 转成Replication所要求的xml参数
 * @param {*} rule
 * {prefix: '', deleteMarkerStatus: '', targetBucket: ''}
 */
function convertToReplicationXML (rule) {
	let xml = '<Replication xmlns="http://s3.amazonaws.com/doc/2006-03-01/">'

	const parsePrefix = val => {
		xml += `<prefix>${val}</prefix>`
	}
	if (rule.prefix) {
		toArray(rule.prefix).forEach(parsePrefix)
	}

	xml += `<DeleteMarkerStatus>${rule.deleteMarkerStatus}</DeleteMarkerStatus>`
	xml += `<targetBucket>${rule.targetBucket}</targetBucket>`
	xml += '</Replication>'
	return xml
}

/**
 * 将json 转成xml
 * @param {*} obj 
 * @returns 
 */
function objToXml (obj) {
	let xml = ''
	obj = formatObjKey(obj)
	if (getType(obj) === 'object') {
		Object.keys(obj).forEach(key => {
			const value = obj[key]
			const type = getType(value)
			if (type !== 'undefined'  && type !== 'null') {
				if (type === 'string' || type === 'number') {
					xml += `<${key}>${value}</${key}>`
				} else if (type === 'array') {
					xml += value.map(item => {
						return `<${key}>${objToXml(item)}</${key}>`
					}).join('')
				} else if (type === 'object') {
					xml += `<${key}>${objToXml(value)}</${key}>`
				} else {
					xml += `<${key}>${value.toString()}</${key}>`
				}
			}
		})
	} else {
		xml += obj.toString()
	}
	return xml
}

function checkDateAndDays (obj) {
	const { days, date } = obj;
	if (days && !/^[1-9][0-9]*$/.test(days)) {
		throw new Error('Days must be a positive integer');
	} else if (date && !/\d{4}-\d{2}-\d{2}T00:00:00\+08:00/.test(date)) {
		throw new Error( `[${date}] ` + 'Date must be date and tranform to iso8601 format, and should be beijing date');
	}
}

/***
 * 检查生命周期的规则是否合法
 */
function checkLifecycleRule (rule) {
	const { id, filter, expiration, status } = rule
	let { transition } = rule
	const { prefix, tag } = filter.and || filter
	if (id && getStrBytesCount(id) > 255) {
		throw new Error('the ID max length is 255 bytes')
	}

	if (prefix && isArray(prefix) && prefix.length > 1) {
		throw new Error('Prefix can only has one value in single rule')
	}

	if (!status) {
		throw new Error('require the Status')
	} else {
		if (!['Enabled', 'Disabled'].includes(status)) throw new Error('Status value only in Enable/Disabled')
	}

	if (!expiration) {
		throw new Error('require the Expiration')
	} else {
		// Date和Days只能二选一，并且不能不选，必须填写其中一个。
		if (expiration.date && expiration.days) throw new Error('Expiration only has one element which in Date/Days')
		if (!expiration.date && !expiration.days) throw new Error('Expiration must has one element')
		checkDateAndDays(expiration)
	}

	if (transition) {
		// transition maybe has more than one
		if (!isArray(transition)) transition = [transition]
		transition.forEach(item => {
			if (item.date && item.days) throw new Error('Transition only has one element which in Date/Days')
			if (!item.date && !item.days) throw new Error('Transition must has one element')
			if (!['STANDARD_IA', 'ARCHIVE'].includes(item.storageClass)) throw new Error('Transition StorageClass value only choose from STANDARD_IA/ARCHIVE')
			checkDateAndDays(item)
		})
	}
}

const  COMMON_RULES = [{
	pattern: /^\S.*/,
	msg: 'can not start with space char'
}, {
	pattern: /.*\S$/,
	msg: 'can not end with space char'
}, {
	pattern: /^[a-zA-Z0-9 +-=._:/]+$/,
	msg: 'tag can contain letters, numbers, spaces, and the following symbols: (+), (-), (=), (.), (_), (:), and (/)'
}]

const TAG_RULES = {
	key: [...COMMON_RULES,
	  {
		pattern: /^.{1,128}$/,
		msg: 'tag key can be a maximum of 128 bytes in length'
	}],
	value: [...COMMON_RULES,
	  {
		pattern: /^.{1,256}$/,
		msg: 'tag key value can be a maximum of 256 bytes in length'
	}]
}

function checkValid (tag) {
	const { key, value } = tag
	TAG_RULES.key.forEach(item => {
		if (!key) throw new Error('key is can not null')
		if (!item.pattern.test(key) ) throw new Error(item.msg)
	})

	TAG_RULES.value.forEach(item => {
		if (!value) throw new Error('value is can not null')
		if (!item.pattern.test(value)) throw new Error(item.msg)
	})

}

/**
 * 检查tag是否合法
 * @param {*} tags
 */
function checkTag (tags) {
	if (tags.length > 10) throw new Error('Taggings length max value is 10')
	let keys = tags.map(x => x.key)
	keys = [...new Set(keys)]
	// Key不可重复
	if (keys.length != tags.length) throw new Error('key cannot repeat')

	tags.forEach(tag => {
		checkValid(tag)
	})
}

/**
 * 获取object的元数据
 * @param {*} reponse - 返回的reponse
 */
function getObjectMetadata(reponse) {

 	const headers = reponse.headers

	 // 不展示的信息
	const exclude = ['connection', 'x-application-context', 'x-kss-request-id', 'server']

	const res = {}
	for (let key in headers) {
		if (exclude.indexOf(key) < 0) {
			res[key] = headers[key]
		}
	}
	return res
}

function isStream (stream) {
	return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
}


// 将当前时间转成 20220414T093758Z
function getStsDate () {
	let d = (new Date()).toISOString() // "2022-04-14T09:48:03.586Z"
	d = d.replace(/-/g, '').replace(/:/g, '')
	d = d.split('.')[0]
	return d + 'Z'
}

/**
 * 将obj中的空置去掉
 * @param {*} obj 
 */
function clearEmpty (obj) {
	let res = {}

	for (let k in obj) {
		const v = obj[k]
		if (v || v == 0) {
			res[k] = v
		}
	}
	return res
}

/**
 * 验证是否符合服务端加密方式。目前合法值：AES256
 * @param {*} encrypt 
 */
function verifyServerEncryption (encrypt) {
	return encrypt == 'AES256'
}

module.exports = {
	isArray,
	isObject,
	verifyBucket: verifyBucket,
	verifyAcl: verifyAcl,
	verifyBucketType: verifyBucketType,
	verifyStorageClass: verifyStorageClass,
	encodeKey: encodeKey,
	walkFile: walkFile,
	walkDir: walkDir,
	xml2json: xml2json,
	getDate: function() {
		return (new Date()).toUTCString();
	},
	getStsDate,
	getExpiresTime,
	getTotalChunk,
	getChunk: getChunk,
	generateCompleteXML,
	getContentTypeByKey,
	getETagsFromXml,
	paramsEncode,
	getFileMd5,
	getStringMd5,
	convertToCORSXML,
	convertToReplicationXML,
	objToXml,
	checkLifecycleRule,
	checkTag,
	getObjectMetadata,
	isStream,
	clearEmpty,
	encodePresignedUrlKey,
	verifyServerEncryption
}

