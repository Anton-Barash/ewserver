var requestPromise = require('request');
var config = require('./../config');
var utils = require("./util")
var xml2json = utils.xml2json;
var debug = require('debug')('request');
const self = this

function makeRequest(req, body, headers, cb) {
	var uri = req.uri;
	var headers = headers || {};
	var data = {
		headers: headers,
		method: req.method,
		timeout: req.timeout || 1000 * 60 * 60,
		followAllRedirects: true // 非get请求也自动重定向
	}

	/**/
	if (Buffer.isBuffer(body) || typeof body === 'string' || utils.isStream(body)) {
		data.body = body;
		if (!utils.isStream(body)) data.headers['Content-Length'] = body.length
	} else if (utils.isObject(body)) {
		data.data = body;
	} else if (body) {
		data.stream = body;
		//data.data = form;
	} else {
		data.headers['Content-Length'] = 0;
	};

	const request = requestPromise(uri, data, function(err, response, body) {
		var rerr = null;

		if (err || Math.floor(response.statusCode / 100) !== 2) {
			rerr = {
				code: response && response.statusCode || - 1,
				error: err || body.error || body || ''
			};
		}

		debug('err',err);
		debug('response',response);
		if (cb) {
			var data = '';
			if ( !!body) {
				var dataStr = body.toString();
				data = dataStr;
				const dataType = req.dataType || config.dataType
				if ( dataType === 'json') {
					dataStr = dataStr.replace(/\s\w+\:\w+=\"\S+\"/g, '');
					var json = xml2json.parser(dataStr);
					data = json;
				}
			}
			debug('data',data);
			// 增加原始数据流,因为在写文件的时候
			// `buf.toString` 会有问题
			// rerr: 异常信息
			// data: 转格式后的数据
			// response: response
			// body: 原始数据
			cb(rerr, data, response, body);
		}
	});


	// upload progress
	if (req.onProgress && typeof req.onProgress === 'function') {
        var contentLength = data.headers['Content-Length'];
        var time0 = Date.now();
        var size0 = 0;
        request.on('drain', function () {
            var time1 = Date.now();
            var loaded = 0;
            try {
                // 已经上传的字节数 = socket当前累计发送的字节数 - 头部长度 - socket以前发送的字节数
                loaded = request.req.connection.bytesWritten - request.req._header.length - (request.req.connection._lastBytesWritten || 0);
            } catch (e) {
            }
            var total = contentLength;
            var speed = parseInt((loaded - size0) / ((time1 - time0) / 1000) * 100) / 100 || 0;
            var percent = parseInt(loaded / total * 100) / 100 || 0;
            time0 = time1;
            size0 = loaded;
            req.onProgress({
                loaded: loaded,
                total: total,
                speed: speed,
                percent: percent,
            });
        });
    }

	// download progress
	if (req.onDownloadProgress && typeof req.onDownloadProgress === 'function') {
        var time0 = Date.now();
        var size0 = 0;
        var loaded = 0;
        var total = 0;
        request.on('response', function (res) {
            total = res.headers['content-length'];
            request.on('data', function (chunk) {
                loaded += chunk.length;
                var time1 = Date.now();
                var speed = parseInt((loaded - size0) / ((time1 - time0) / 1000) * 100) / 100 || 0;
                var percent = parseInt(loaded / total * 100) / 100 || 0;
                time0 = time1;
                size0 = loaded;
                req.onDownloadProgress({
                    loaded: loaded,
                    total: total,
                    speed: speed,
                    percent: percent,
                });
            });
        });
    }

	return request;
}

function sendRequest(req, body, token, cb) {

	// add debug mode
	requestPromise.debug = config.isDebug

	var headers = {
		'Content-Type': (typeof req.type !== 'undefined') ? req.type: config.contentType,
		'User-Agent': req.ua || config.ua,
		// warning: 这个地方需要注意,因为后端的token产生需要`date`,所以需要在请求的时候,把用于计算授权的`date`再传给后端,
		// 不能自己生成,否则token就报错了
		date: req.date,
		Authorization: token,
		'Content-Length': ( !! req.body) ? req.body.length: 0
	};

	if (req.headers) {
		for (var it in req.headers) {
			headers[it] = req.headers[it];
		}
	}

	req.timeout = this.timeout
	
	// if domainMode is true, should delete bucketName
	if (this.domainMode) {
		console.log('req.uri: ', req.uri)
		if (req.uri.indexOf(this.bucketName) > -1) {
			const regExp = new RegExp(this.bucketName + '.', 'gim')
			req.uri = req.uri.replace(regExp, '')
		}
	}

	// 传输的字节总数
	self.totalBytes = headers['Content-Length'] || 0

	const request = makeRequest(req, body, headers, cb);

	return request
}

module.exports = sendRequest;