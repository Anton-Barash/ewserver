var KS3 = require('..');
var should = require('should');
require('should-http');
var path = require('path');
var _dataType = require('../config').dataType;
var fs = require('fs');
const { setDefaultResultOrder } = require('dns');
var util = require('../lib/util')
const { ak, sk } = require('./config')

const bucketName = 'test-sdk-' + (Date.now())

describe('API Object', function() {

	var client = new KS3(ak, sk, bucketName);
	client.config({
		dataType: 'json'
	})

	var key = 'word.txt'
	var acl = 'public-read'
	var storageClass = 'ARCHIVE'
	var ServerSideEncryption = 'AES256'

	before (function (done) {
		this.timeout(30000)
		client.bucket.put(function(err, data, res) {
			if (!err) {
				client.object.put({
					Key: key,
					FilePath: path.join(__dirname, './assets/' + key),
					ACL: acl
				}, function (err, data, res) {
					should.not.exist(err)
					done()
				})
			}
		});
	})


	describe('bucket name is empty', function() {
		it('return a error', function() {
			var client = new KS3(ak, sk);
			(function() {
				client.object.get({
					Key: 'test/'
				},
				function() {});
			}).should.throw ('require the bucket name');
		})
	});

	describe('Key is empty', function() {
		it('return a error', function() { (function() {
				client.object.get(function() {});
			}).should.
			throw ('require the Key');
		})
	});

	describe('put ', function() {
		describe('upload a file', function() {
			it('upload a object with string content', function(done) {
				var content = 'Hello world';
				var key = 'test_upload.txt';
				client.object.put({
					Bucket: bucketName,
					Key: key,
					Body: content
				},
				function(err, data, res) {
					should.not.exist(err);
					res.should.have.status(200);
					done();
				});
			});
			it('upload a object with string content with key name including /', function(done) {
				var content = 'Hello world3';
				var key = '/test.中//\\文?？.key///';
				client.object.put({
						Bucket: bucketName,
						Key: key,
						Body: content
					},
					function(err, data, res) {
						should.not.exist(err);
						res.should.have.status(200);
						client.object.get({
							Bucket:bucketName,
							Key:key
						},function(err,data,res){
							//console.log('__dirname :' + __dirname);
							data.should.have.length(12);
							done();
						});

					});
			});

			it('put object and set acl', function(done) {
				var content = 'Hello world';
				var key = 'test_upload_acl.txt';
				var acl = 'public-read-write';
				client.object.put({
					Bucket: bucketName,
					Key: key,
					Body: content,
					ACL: acl
				},
				function(err, data, res) {
					should.not.exist(err);
					res.should.have.status(200);
					done();
				});
			});
			it('upload a object with buffer content && get a object', function(done) {
				var buf = new Buffer('Hello world');

				var key = 'test_upload_buffer.txt';
				client.object.put({
					Bucket: bucketName,
					Key: key,
					Body: buf
				},
				function(err, data, res) {
					client.object.get({
						Bucket:bucketName,
						Key:key
					},function(err,data,res){
						data.should.have.length(11);
						done();
					});
				});
			});

			it('upload a object with content type && get the object', function(done) {
				var buf = new Buffer('<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><title>测试</title></head><body>testing page for gulp-ks3</body></html>');
				var key = 'test_upload_buffer';
				client.object.put({
						Bucket: bucketName,
						Key: key,
						Body: buf,
						headers: {
							'Content-Type':'text/html'
						}
					},
					function(err, data, res) {
						client.object.get({
							Bucket:bucketName,
							Key:key
						},function(err,data,res){
							res.headers['content-type'].should.equal('text/html');
							done();
						});
					}
				);
			});

			it('upload a object with file content && get a object', function(done) {
				var fileName = 'photo.jpg';
				var filePath = path.join(__dirname,'./assets/'+fileName);
				var key = 'test_upload_'+fileName;
				var upFileStat = fs.statSync(filePath);
				client.object.put({
					Bucket: bucketName,
					Key: key,
					FilePath:filePath
				},
				function(err, data, res) {
					should.not.exist(err);
					res.should.have.status(200);
					client.object.get({
						Bucket:bucketName,
						Key:key,
						DataType: 'xml'
					},function(err,data,res,originData){
						should.not.exist(err);
						var newFileName = path.join(__dirname,'assets/test_object_get_download_'+fileName);
						fs.writeFileSync(newFileName,originData);
						var downFileStat = fs.statSync(filePath);
						(downFileStat.size).should.equal(upFileStat.size);
						done();
					});
				});
			});
			it('get a not exists file', function(done) {
				var key = 'file_no_exist.jpg';
				client.object.get({
					Bucket:bucketName,
					Key:key
				},function(err,data,res){
					should.exist(err);
					err.code.should.equal(404);
					res.statusCode.should.equal(404);
					done();
				});
			});
			it('upload a object with file content', function(done) {
				var filePath = path.join(__dirname, './assets/test_upload_file.txt');
				var key = 'test_upload_file.txt';

				client.object.put({
					Bucket: bucketName,
					FilePath: filePath,
					Key: key
				},
				function(err, data, res) {
					should.not.exist(err);
					res.should.have.status(200);
					done();
				});

			});

			it('upload a photo file', function(done) {
				var filePath = path.join(__dirname, './assets/test_upload_photo.jpg');
				var key = 'test_upload_photo.jpg';

				client.object.put({
					ACL: 'public-read',
					FilePath: filePath,
					Key: key
				},
				function(err, data, res) {
					should.not.exist(err);
					res.should.have.status(200);
					done();

				});
			});
		});
	});

	describe('get ', function () {
		it('Range header', function (done) {
			client.object.get({
				Key: key,
				headers: {
					Range: 'bytes=0-9'
				}
			}, function (err, data, res) {
				should.equal(res.caseless.get('content-length'), '10')
				// should.equal(Buffer.isBuffer(data), true)
				should.equal(data.toString(), '申明:本')
				done()
			})
		})

		it('return Stream', function (done) {
			const req = client.object.getObjectStream({
				Key: 'word.txt'
			})
			should.equal(util.isStream(req), true)
			done()
		})
	})

	describe('upload a big size file by multitpart ', function() {
		it('initiates a multipart upload and returns an upload ID', function(done) {
			client.config({
				dataType: 'json'
			});
			var key = 'bigFile.mov';

			client.object.multitpart_upload_init({
				Key: key
			},
			function(err, data, res) {
				should.not.exist(err);
				res.should.have.status(200);
				should.exist(data.InitiateMultipartUploadResult.UploadId);
				(data.InitiateMultipartUploadResult.UploadId).should.have.length(32);
				done();
			});
		});
		it('uploads a part in a multipart upload', function(done) {
			client.config({
				dataType: 'json'
			});
			var key = 'bigFile.mov';

			client.object.multitpart_upload_init({
				Key: key
			},
			function(err, data, res) {
				var uploadId = data.InitiateMultipartUploadResult.UploadId
				client.config({
					dataType: 'xml'
				});
				client.object.upload_part({
					Key: key,
					PartNumber: 1,
					Body: 'API Object put test : uploads a part in a multipart upload',
					UploadId: uploadId
				},
				function(err, data, res) {
					// 这个地方比较特殊,返回的结果是放在header里的,而不是data里面
					// 而且返回的etag还是带着双引号的,形如:etag: '"d41d8cd98f00b204e9800998ecf8427e"
					should.not.exist(err);
					res.should.have.status(200);
					should.exist(res.headers.etag);
					done();
				});
			});
		});

		it('completes a multipart upload by assembling previously uploaded parts', function(done) {
			client.config({
				dataType: 'json'
			});
			var key = 'bigFile.mov';

			client.object.multitpart_upload_init({
				Key: key
			},
			function(err, data, res) {
				if (err) throw err;
				var uploadId = data.InitiateMultipartUploadResult.UploadId;
				client.config({
					dataType: 'xml'
				});
				client.object.upload_part({
					Key: key,
					PartNumber: 1,
					Body: 'API Object put test : uploads a part in a multipart upload',
					UploadId: uploadId
				},
				function(err, data, res) {
					if (err) throw err;
					var etag = res.headers.etag;

					client.object.upload_complete({
						Key: key,
						UploadId: uploadId,
						Body: (function() {
							var sample = ['<CompleteMultipartUpload>', '<Part>', '<PartNumber>' + 1 + '</PartNumber>', '<ETag>' + etag + '</ETag>', '</Part>', '</CompleteMultipartUpload>'];
							return sample.join('');
						})()
					},
					function(err, data, res) {
						should.not.exist(err);
						res.should.have.status(200);
						done();
					})
				});
			});
		});

		it('aborts a multipart upload', function(done) {
			client.config({
				dataType: 'json'
			});
			var key = 'bigFile1.mov';

			client.object.multitpart_upload_init({
				Key: key
			},
			function(err, data, res) {
				if (err) throw err;
				var uploadId = data.InitiateMultipartUploadResult.UploadId
				client.object.upload_abort({
					Key: key,
					UploadId: uploadId
				},
				function(err, data, res) {
					should.not.exist(err);
					res.should.have.status(204);
					done();
				});
			});
		});

		it('lists the parts that have been uploaded for a specific multipart upload', function(done) {
			client.config({
				dataType: 'json'
			});
			var key = 'bigFile.mov';

			client.object.multitpart_upload_init({
				Key: key
			},
			function(err, data, res) {
				var uploadId = data.InitiateMultipartUploadResult.UploadId
				client.config({
					dataType: 'xml'
				});
				client.object.upload_part({
					Key: key,
					PartNumber: 1,
					Body: 'API Object put test : uploads a part in a multipart upload',
					UploadId: uploadId
				},
				function(err, data, res) {
					if (err) throw err;
					client.object.upload_list_part({
						Key: key,
						UploadId: uploadId
					},
					function(err, data, res) {
						should.not.exist(err);
						res.should.have.status(200);
						done();
					})

				});
			});

		});
	});

	describe('all of object process', function() {
		var content = 'Hello world';
		var key = 'test_upload.txt';
		before(function() {
			client.object.put({
				Bucket: bucketName,
				Key: key,
				Body: content
			},
			function() {})
		});
		it('should be return string width get object', function(done) {
			client.config({
				dataType: 'xml'
			});
			client.object.get({
				Bucket: bucketName,
				Key: key
			},
			function(err, data, res) {
				should.not.exist(err);
				res.should.have.status(200);
				(data === content).should.be.ok;
				done();
			})
		});
		// HEAD object
		it('should be return a 200 statuscode width head object', function(done) {
			client.object.head({
				Key: key
			},
			function(err, data, res) {
				should.not.exist(err);
				res.should.have.status(200);
				done()
			})
		});
		it('should be return a 200 statuscode with put object ACL', function(done) {
			// putAcl 测试
			client.object.putAcl({
				Key: key,
				ACL: 'public-read'
			},
			function(err, data, res) {
				should.not.exist(err);
				res.should.have.status(200);
				done();
			})
		});
		it('should be return a json object with get object ACL', function(done) {
			client.config({
				dataType: 'json'
			});
			// getAcl测试
			client.object.getAcl({
				Key: key
			},
			function(err, data, res) {
				var d = data.AccessControlPolicy.AccessControlList.Grant;
				(d[0]['Permission'] === 'FULL_CONTROL' && d[1]['Permission'] === 'READ').should.be.ok;
				should.not.exist(err);
				res.should.have.status(200);
				done();
			})
		});

		// getACLType
		it('get acl type ', function (done) {
			client.object.getACLType({
				Key: key
			}, function (err, type, res){
				should.not.exist(err)
				should.equal(type, 'public-read')
				done()
			})
		})

		// copy
		it('copy require destinationBucket and destinationObject', function () {
			(function () {
				client.object.copy({}, function (err, data, res) {})
			}).should.throw()
		})
		
		it('copy object', function (done) {
			client.object.copy({
				destinationBucket: bucketName,
				destinationObject: key + '-copy',
				sourceBucket: bucketName, 
				sourceKey: key
			}, function (err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		// generatePresignedUrl
		it('generatePresignedUrl ', function (done) {
			client.object.generatePresignedUrl({ Key: key, expiration: 2000 }, function(err, url, res) {
				should.not.exist(err)
				url.should.startWith('http');
				done()
			})
		})

		// putObjectTagging
		it('put object tagging', function (done) {
			client.object.putObjectTagging({
				 Key: key,
				Taggings: [{
					key: '22',
					value: 'aa'
				}] 
			}, function(err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		// getObjectTagging
		it('get object tagging', function (done) {
			client.object.getObjectTagging({ Key: key }, function(err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		// deleteObjectTagging
		it('delete object tagging', function (done) {
			client.object.deleteObjectTagging({ Key: key }, function(err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		var newName = key + '-newName'
		// rename
		it('rename object', function (done) {
			client.object.rename({ Key: key, newKey: newName }, function(err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		// modifyStorageClass
		it('modify storageClass object', function (done) {
			client.object.modifyStorageClass({ Key: newName, storageClass }, function(err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		// restore
		it('restore object', function (done) {
			client.object.restore({ Key: newName }, function(err, data, res) {
				should.not.exist(err)
				done()
			})
		})


		it('should be return 204 statuscode with delete object', function(done) {
			// 都跑过之后 删除object
			client.object.del({
				Bucket: bucketName,
				Key: newName
			},
			function(err, data, res) {
				should.not.exist(err);
				res.should.have.status(204); // 删除成功返回的是204
				done();
			})
		});
	});


	// 加密相关
	describe('encrypt', function () {
		it('return a error, only AES256 supported.', function() { 
			(function() { client.object.put({
				Body: 'This is a encrypt content ~',
				Key: key,
				ServerSideEncryption: 'AES128'
			}, function (){}) }).should.throw ('check your encrypt type, we now only support "AES256".');
		})
		
		it('upload and set encrypt', function(done) {
			client.object.put({
				Body: 'This is a encrypt content ~',
				Key: key,
				ServerSideEncryption
			}, function (err, data, res){
				should.not.exist(err)
				res.should.have.status(200)
				done()
			})
		})

		it('copy encrypt file', function (done) {
			client.object.copy({
				destinationBucket: bucketName,
				destinationObject: key + '-copy',
				sourceBucket: bucketName, 
				sourceKey: key
			}, function (err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		it('update file storageClass', function (done) {
			client.object.modifyStorageClass({
				Key: key,
				storageClass: 'STANDARD_IA'
			}, function (err, data, res) {
				should.not.exist(err)
				done()
			})
		})

		it('rename encrypt file', function(done) {
			client.object.rename({
				Key: key,
				newKey: 'new-' + key
			}, function (err, data, res) {
				should.not.exist(err)
				done()
			})
		})
	})

	after(function (done) {
		client.config({
			dataType: 'json'
		});

		this.timeout(30000)
		// 获取bucket数据 --> 循环删除object --> 删除bucket
		client.bucket.get(function(err, data, res){
			if (err) {
				throw Error(err)
			}
			const objects = data.ListBucketResult.Contents
			const promiseQueue = []
			objects.forEach(item => {
				const p = new Promise(function(resolve, reject){
					client.object.del({
						Key: item.Key
					}, function (err, data, res) {
						if (err) {
							reject(err)
						}
						resolve()
					})
				})
				promiseQueue.push(p)
			})

			Promise.all(promiseQueue).then(val => {
				client.bucket.del(function (err, data, res) {
					should.not.exist(err)
					res.should.have.status(204)
					done()
				})
			}).catch(err => {
				done()
			})
		})
	});
});

